%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Short Sectioned Assignment
% LaTeX Template
% Version 1.0 (5/5/12)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Frits Wenneker (http://www.howtotex.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[paper=letter, fontsize=13pt]{article} % A4 paper and 11pt font size

\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
%\usepackage{fourier} % Use the Adobe Utopia font for the document - comment this line to return to the LaTeX default
\usepackage[english]{babel} % English language/hyphenation
\usepackage{amsmath,amsfonts,amsthm} % Math packages

%\usepackage{sectsty} % Allows customizing section commands
%\allsectionsfont{\centering \normalfont\scshape} % Make all sections centered, the default font and small caps
  

\usepackage{color}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{inconsolata}
\usepackage{framed}

\lstset{language=Haskell}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{myblue}{rgb}{0.2,0.2,0.8}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
%  numbers=left,
  basicstyle=\ttfamily,
  showstringspaces=false,
  backgroundcolor=\color{white},   % choose the background color
%  breaklines=true,                 % automatic line breaking only at whitespace
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  escapeinside={(*}{*)},          % if you want to add LaTeX within your code
  keywordstyle=\color{mymauve},       % keyword style
}

% Add your keywords here, and have this in a separate file
% and include it in your preamble
\lstset{emph={%  
    DECR,EQL,TRUE, FALSE, ITE, NOT, AND, OR, PAIR, FST, SND, ZERO, ONE,% 
    TWO, THREE, FOUR, FIVE, INC, ADD, MUL, ISZ, GET, APPEND, REVERSE, FIX, EMPTY, S\_GET, CONVERT, LENGTH%
    },emphstyle={\bfseries}%
}%


\usepackage[margin=1in]{geometry}
%\usepackage{fancyhdr} % Custom headers and footers
%\pagestyle{fancyplain} % Makes all pages in the document conform to the custom headers and footers
%\fancyhead{} % No page header - if you want one, create it in the same way as the footers below
%\fancyfoot[L]{} % Empty left footer
%\fancyfoot[C]{} % Empty center footer
%\fancyfoot[R]{\thepage} % Page numbering for right footer
%\renewcommand{\headrulewidth}{0pt} % Remove header underlines
%\renewcommand{\footrulewidth}{0pt} % Remove footer underlines
%\setlength{\headheight}{13.6pt} % Customize the height of the header


\numberwithin{equation}{section} % Number equations within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
%\numberwithin{figure}{section} % Number figures within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
%\numberwithin{table}{section} % Number tables within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)

%\setlength\parindent{0pt} % Removes all indentation from paragraphs - comment this line for an assignment with lots of text

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} % Create horizontal rule command with 1 argument of height
\newif\ifshowanswers\showanswerstrue

\title{\vspace{-2em} 	
\normalfont \normalsize 
%\horrule{0.5pt} \\[0.4cm] % Thin top horizontal rule
{\huge CSE 116, Fall 2019 Final} \\ % The assignment title
\horrule{2pt} \\[0.5cm] % Thick bottom horizontal rule
}
\date{\vspace{-4em}} % Today's date or a custom date

\begin{document}

\maketitle % Print the title

%----------------------------------------------------------------------------------------
%	PROBLEM 1
%----------------------------------------------------------------------------------------

% TODO : Random list?
% https://tex.stackexchange.com/questions/96645/random-shuffle-itemize
\begin{center}
 {\Large
\begin{tabular}{|c|c|c|}
\hline
\textbf{Section} & \textbf{Points} & \textbf{Score} \\
\hline
Part I     & 35 points  & \\
\hline
Part II   &  36 points &   \\
\hline
Part III   &  97 points &   \\
\hline
 \textbf{Total} & 168 points &   \\
\hline
\end{tabular}
}

\end{center}
\large 


\paragraph{\textbf{ Instructions} }
\begin{itemize}

\item \textbf{You have 180 minutes to complete this exam.}

\item This exam is \textbf{closed book}.  You may use one double-sided
page of notes, but no other materials.

\item Avoid seeing anyone else's work or allowing yours to be seen.

\item Do not communicate with anyone but an exam proctor.

\item To ensure fairness (and the appearance thereof),
  \textbf{proctors will not answer questions about the content of the exam}. If you are unsure 
  of how to interpret a problem description, state your interpretation clearly and concisely. 
  \textit{Reasonable interpretations} will be taken into account by graders.

\end{itemize}

\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\noindent NAME: \verb|____________________________________________________| \\
\bigskip\\ 
\bigskip\\
CruzID: \verb|_______________________________| @ucsc.edu

\newpage
\noindent {\Huge \textbf{Part I: Lambda calculus}}

\bigskip

\begin{enumerate} 
 \item \textbf{[5pts]} What are the free variables of the lambda calculus expression \\
           \verb|(\a -> a (\b -> c) (\d e -> a d)) (\h i -> g)|
          \begin{enumerate}
          \item b, e, h, i
          \item a, b, d, e, h, i
          \item a, c, d, g
          \item a, c, g
          \item c, g
          \item None of the above
          \end{enumerate}

\ifshowanswers
ANSWER E: c, g
\fi

\item \textbf{[14pts]} Use $\beta$-reductions to evaluate the following lambda terms to a normal form. \\
\bigskip
\bigskip
\begin{enumerate}[label=(\Alph*)]
\item 
\verb|(\x y -> x y (\a b -> a)) (\c d -> c) (\e f -> f)|
\ifshowanswers
%\begin{verbatim}
%(((λx.(λy.((x y)(λa.(λb.a)))))(λc.(λd.c)))(λe.(λf.f)))
%=b> ((λy.(((λc.(λd.c))y)(λa.(λb.a))))(λe.(λf.f)))
%=b> (((λc.(λd.c))(λe.(λf.f)))(λa.(λb.a)))
%=b> ((λd.(λe.(λf.f)))(λa.(λb.a)))
%=b> (λe.(λf.f))
Rubric:
\begin{itemize}
\item 0 pts : no attempt or nothing correct.
\item 1 pts : anything correct (e.g., one reduction)
\item 2-5 pts : more than one thing correct (e.g., two reductions), few things incorrect
\item 6 pts : almost correct, but one smallish error
\item 7 pts : completely correct
\end{itemize}
\else
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\fi

\item 
\verb|(\z x y -> x y (z y)) (\a -> a (\b c -> c) (\d e -> d)) (\f g -> g) (\h i -> i)|
\ifshowanswers
\begin{itemize}
\item \verb|(\x y -> x y ((\a -> a (\b c -> c) (\d e -> d)) y)) (\f g -> g) (\h i -> i)|
\item \verb|(\y -> (\f g -> g) y ((\a -> a (\b c -> c) (\d e -> d)) y)) (\h i -> i)|
\item \verb|((\f g -> g) (\h i -> i) ((\a -> a (\b c -> c) (\d e -> d)) (\h i -> i)))|
\item \verb|((\g -> g) ((\a -> a (\b c -> c) (\d e -> d)) (\h i -> i)))|
\item \verb|(\h i -> i) (\b c -> c) (\d e -> d)|
\item \verb|(\i -> i) (\d e -> d)|
\item \verb|(\d e -> d)|
\end{itemize}

Rubric:
\begin{itemize}
\item 0 pts : no attempt or nothing correct.
\item 1 pts : anything correct (e.g., one reduction)
\item 2-5 pts : more than one thing correct (e.g., two reductions), few things incorrect
\item 6 pts : almost correct, but one smallish error
\item 7 pts : completely correct
\end{itemize}
\else
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\fi
\end{enumerate}
\newpage

\item \textbf{[16pts]}  
We can represent lists in lambda calculus using \texttt{PAIR} and \texttt{FALSE}.
For example, the Haskell list \texttt{[0, 1, 2]} can be represented in Lambda Calculus
as 
\begin{verbatim}
PAIR ZERO (PAIR ONE (PAIR TWO FALSE))
\end{verbatim}
and functions like Haskell's \texttt{head} and \texttt{tail} can be implemented by \texttt{FST} 
and \texttt{SND}, respectively. In the Haskell cheat sheet, you will also find \texttt{EMPTY}, 
which returns \texttt{TRUE} if applied to an empty list 
\begin{verbatim}
EMPTY FALSE =~> TRUE
\end{verbatim}
and returns \texttt{FALSE} otherwise:
\begin{verbatim}
EMPTY (PAIR ZERO (PAIR ONE (PAIR TWO FALSE))) =~> FALSE
\end{verbatim}

Fill in a lambda calculus expression for each blank in the program
below to define a function \texttt{FILTER} such that for a predicate function \texttt{p} and a list \texttt{l},
\texttt{(FILTER p l)} returns a list containing every element \texttt{v} of \texttt{l} such that \verb|(p v) =~> TRUE|.
You may use any of the functions defined on the Lambda Calculus Cheat Sheet on the back page. 

\ifshowanswers
\begin{verbatim}
let FILTER1 = \f p l -> ITE (EMPTY l)
                          FALSE
                          ITE (p (FST l))
                            (PAIR (FST l) (f p (SND l)))
                            (f p (SND l))
                      
let FILTER  = FIX FILTER1
\end{verbatim}
\else
\begin{verbatim}
let FILTER1 = \f p l -> ITE _____(A)_______
                            _____(B)_______
                           (ITE _____(C)_______
                                _____(D)_______
                                _____(E)_______)
                               
let FILTER  = ______(F)_______
\end{verbatim}
\fi

\begin{enumerate}[label=(\Alph*)]
   \item \bigskip \bigskip
   \item \bigskip \bigskip
   \item \bigskip \bigskip
   \item \bigskip \bigskip
   \item \bigskip \bigskip
   \item \bigskip \bigskip
\end{enumerate}

\newpage
\noindent {\Huge \textbf{Part II: Nano}}

Consider the following grammar and operational semantics, and type system for Nano1.
{\Large \textbf{Grammar}}
\begin{lstlisting}
e ::= v 
    | e1 e2

v ::= x | n  
    | \x -> e       
\end{lstlisting}

{\Large \textbf{Operational semantics}}
\begin{verbatim}
           e1 => e1'
[App-L] ----------------
        e1 e2 => e1' e2
        
          e => e'
[App-R] ------------
        v e => v e'        
        
[App]   (\x -> e) v => e[x := v]          

               e1 => e1'
[Add-L]   --------------------
          e1 + e2 => e1' + e2

              e2 => e2'
[Add-R]   --------------------
          n1 + e2 => n1 + e2'
          
[Add]     n1 + n2 => n       where n == n1 + n2          

                        e1 => e1'
[Let-Def] --------------------------------------
          let x = e1 in e2 => let x = e1' in e2
        
[Let]     let x = v in e2 => e2[x := v]
\end{verbatim}


\begin{verbatim}
\end{verbatim}
\newpage
%  %% Fill in a step proof
\item \textbf{[21pts]}  
Below are partial proofs that the expression 
\verb|(\x -> \y -> x + y) (1+1) 6|
evaluates to \texttt{8}.
For each blank, fill in a typing rule or expression to complete the proof.
\bigskip

\begin{itemize}
  \item
\begin{verbatim}
[Add]   --------
        1+1 => 2
[__a__] -------------------------------------------------
        (\x -> \y -> x + y) (1+1) => (\x -> \y -> x + y) 2
[__b__] ------------------------------------------------------
        (\x -> \y -> x + y) (1+1) 6 => (\x -> \y -> x + y) 2 6
\end{verbatim}
\bigskip
\bigskip
\bigskip
\bigskip
\item
\begin{verbatim}
[__c__] --------------------------------
        (\x -> \y -> x + y) 2 6 => __d__
\end{verbatim}
\bigskip
\bigskip
\bigskip
\bigskip

      \item
\begin{verbatim}
[__e__] --------------
        __f__ => 2 + 6
\end{verbatim}
\bigskip
\bigskip
\bigskip
\bigskip

\item
\begin{verbatim}
[__g__] ----------
        2 + 6 => 8
\end{verbatim}
\bigskip
\bigskip
\bigskip
\bigskip
\end{itemize}

\begin{enumerate}[label=(\Alph*)]
\ifshowanswers
\item App-R
\item App-L
\item App
\item \verb|(\y -> 2 + y) 6|
\item App
\item \verb|(\y -> 2 + y) 6|
\item Add
\else
\item \bigskip \bigskip
\item \bigskip \bigskip 
\item \bigskip \bigskip 
\item \bigskip \bigskip 
\item \bigskip \bigskip 
\item \bigskip \bigskip 
\item \bigskip \bigskip 
\fi
\end{enumerate}

\newpage
\item \textbf{[5pts]} What is the most general unifier of the following two 
types (where \texttt{a,b,c} are type variables)?
  \[
\begin{array}{l}
  \verb|(a -> b) -> b -> [a] -> b| \\
  \verb|(c -> Bool) -> a -> [c] -> [c]| \\
\end{array}
\]
\begin{enumerate}
\item \verb|[a / Bool, b / Bool, c / Bool]|
\item \verb|[a / Bool, b / [Bool], c / Bool]|
\item \verb|[a / [Bool], b / [Bool], c / Bool]|
\item \verb|[a / c, b / [c]]|
\item None of the above
\item Cannot unify
\end{enumerate}
  \bigskip
  \bigskip
  \bigskip

\item \textbf{[5pts]} What is the most general unifier of the following two types (where \texttt{a,b,c} are type variables)?
  \[
\begin{array}{l}
  \verb|(a -> b) -> [a] -> b| \\
  \verb|(c -> b) -> [c] -> [c]| 
\end{array}
\]
\begin{enumerate}
\item \verb|[b / c, a / b, c / b]|
\item \verb|[a / Bool, b / [Bool], c / Bool]|
\item \verb|[a / [Bool], b / [Bool], c / Bool]|
\item \verb|[a / c, b / [c]]|
\item None of the above
\item Cannot unify
\end{enumerate}
  \bigskip
  \bigskip
  \bigskip

\item \textbf{[5pts]} What is the result of applying the following substitution? 
\begin{verbatim}
 [a / f, b / d, d / (e,e), f / (e -> c)] forall a. forall b. (d -> e -> f) -> (a -> b)
\end{verbatim}
  \ifshowanswers
  \begin{verbatim}
  forall a. forall b. ((e,e) -> e -> (e -> c)) -> (a -> b)
 \end{verbatim}
\else
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \bigskip
  \fi
  

\newpage
\noindent {\Huge \textbf{Part III: Haskell}}
\bigskip
\bigskip
\bigskip

\item \textbf{[5pts]} Given the following definition of \texttt{foo}:
\begin{lstlisting}
foo a b = 
    let c = \a -> b ++ a in
      let b = a ++ (c a) in
       c (bar b)
  where 
    bar e = e ++ a ++ b
\end{lstlisting}
  what does the expression \texttt{foo "x" "o"} evaluate to?
\begin{enumerate}
\item \texttt{"xxxooo"}
\item \texttt{"oxoxxo"}
\item \texttt{"xxooxo"}
\item \texttt{"xoxoxo"}
\item \texttt{"oxoxox"}
\item None of the above
\end{enumerate}

\item \textbf{[5pts]}  What does this Haskell expression evaluate to?
  (See Haskell cheat sheet for definition of map.)
\begin{lstlisting}
map (\(x,y) -> x : [y]) [(0,1),(2,3),(4,5)]
\end{lstlisting}
  \begin{enumerate}
    \item Type error
    \item \verb|[0,1,2,3,4,5]|
    \item \verb|[[0],[1],[2],[3],[4],[5]]|
    \item \verb|[[0,1],[2,3],[4,5]]|
    \item \verb|[[0,1,2,3,4,5]]|
    \item None of the above
  \end{enumerate}

\item \textbf{[5pts]}  What does this Haskell expression evaluate to?
  (See Haskell cheat sheet for definition of foldl.)
\begin{lstlisting}
foldl (:) [] ["a", "b", "c", "d"]
\end{lstlisting}
  \begin{enumerate}
    \item Type error
    \item \verb|"abcd"|
    \item \verb|"dcba"|
    \item \verb|["a","b", "c", "d"]|
    \item \verb|["d","c", "b", "a"]|
    \item None of the above
  \end{enumerate}

\item \textbf{[5pts]}  What does this Haskell expression evaluate to?
  (See Haskell cheat sheet for definition of filter.)
\begin{lstlisting}
filter (\(x, y) -> x + y > 5) [(1,3), (2,4), (3,5), (5,0), (4,1)]
\end{lstlisting}
  \begin{enumerate}
    \item Type error
    \item \verb|(6,8)|
    \item \verb|(2,4,3,5)|
    \item \verb|[6, 8]|
    \item \verb|[(2,4), (3,5)]|
    \item None of the above
  \end{enumerate}
\ifshowanswers
Answer: E
\fi

\item \textbf{[5pts]} 
Recall that \texttt{(.)} is the infix operator for \texttt{compose}, so \texttt{(f.g) x} is the same as writing \texttt{f (g x)}. 
What does the following Haskell program evaluate to? (See the Haskell cheat sheet for types and definitions 
of the functions used below.)
\begin{lstlisting}
(foldr (+) 0 . map (\x -> x*2) . filter even) [1,2,3,4,5]
\end{lstlisting}
  \begin{enumerate}
    \item Type error
    \item 30
    \item 24
    \item 12
    \item 20
    \item None of the above
  \end{enumerate}
\ifshowanswers
Answer: D
\fi
  
\item \textbf{[5pts]} What is the most general type of the Haskell function \texttt{foo}?
\begin{lstlisting}
foo x y z = bar x y (z+1)
  where
    bar = \w u -> u w
\end{lstlisting}
    \begin{enumerate} 
         \item \verb|Num c => a -> b -> c -> a|
         \item \verb|Num c => (b -> c -> a) -> b -> c -> a|
         \item \verb|Num b => a -> (a -> b -> c) -> b -> c|
         \item \verb|Num b => (a -> b -> c -> d) -> a -> b -> c -> d|
         \item Type error
         \item None of the above
     \end{enumerate}
\ifshowanswers
Answer: C
\fi

\newpage
For the following questions, consider the data types defined below.
\begin{lstlisting}
data Binop = Add | Sub | Mul

data Expr = Num Int              
          | Var String
          | Bin Binop Expr Expr  
          | Let String Expr Expr     

\end{lstlisting}

\item \textbf{[15pts]} A \texttt{case} expression is \textit{exhaustive} if all possible values are matched
by at least one pattern. A pattern is \textit{overlapping} if previous patterns match all values it matches.
Assume \texttt{t} has type \texttt{Expr} and do the following:
\begin{itemize}
  \item For each pattern in each \texttt{case}, provide a value that matches on the pattern.
  \item If the pattern is overlapped by a previous pattern, write ``overlapped''.
  \item Determine if the \texttt{case} expression is exhaustive and circle \texttt{Exhaustive} or \texttt{Non-exhaustive} as appropriate.
  \item For non-exhaustive \texttt{case} expressions, write a value that does not match any of its patterns.
\end{itemize}
For example, the following patterns are \textbf{non-exhaustive}: 
\begin{lstlisting}
                            case t of

_Num 4___________             Num n   -> ()

_Var "x"_______________       Var x -> ()

_overlapped_______________       Var _ -> ()

_Bin Mul (Var "x") (Num 1)_   Bin _ x y -> ()

_Let "x" (Num 1) (Num 2)__    Let id _ (Num y) -> ()

_Let "x" (Num 1) (Var "y")__  [ Exhaustive  /  (( Non-exhaustive )) ]
\end{lstlisting}

\newpage
\begin{enumerate}
\item
  {
\begin{lstlisting}
                           case t of


_______________________      Var foo -> ()


_______________________      Bin op x y  -> ()


_______________________      Let x e1 e2 -> ()


_______________________      Num n -> ()


_______________________      _ -> ()


_______________________    [ Exhaustive  /  Non-exhaustive ]
\end{lstlisting}
\bigskip
\bigskip
\bigskip
\bigskip

\item 
\begin{lstlisting}
                            case t of


_______________________       Num 1 -> ()


_______________________       _ -> ()


_______________________    [ Exhaustive  /  Non-exhaustive ]
\end{lstlisting}

\newpage

\item
\begin{lstlisting}
                           case t of


_______________________      Bin Add (Var x) (Var y) 
                               | x ++ y == "foobar" -> ()

_______________________      Bin Add x y -> ()


_______________________      Let _ _ _ -> ()


_______________________      Var x -> ()


_______________________      Num x -> ()


_______________________    [ Exhaustive  /  Non-exhaustive ]
\end{lstlisting}
  }
\bigskip
\bigskip
\bigskip

\end{enumerate}

\newpage
Consider the datatype below for a tree where each internal node has a value (of type \texttt{a}) and two child subtrees, eventually terminating
with a leaf node.  

\begin{verbatim}
data Tree a =  Leaf | Node a (Tree a) (Tree a)
\end{verbatim}

\item \textbf{[2pts]} What is the most general type of the value \texttt{t}?
\begin{verbatim}
t = (Node "foo"  
      (Node "bar" (Node "baz" Leaf Leaf) Leaf) 
      (Node "qux" Leaf (Node "quux" Leaf Leaf)))
\end{verbatim}

\ifshowanswers 
\texttt{Tree String} or \texttt{Tree Char}
\else
\begin{verbatim}

_______________________________________________
\end{verbatim}
\fi

\item \textbf{[10pts]} Implement a fold for the \texttt{Tree} datatype 
so that \texttt{foldTree (++) "" t} evaluates to \texttt{""foobarbazquxquux"}.
You may only use library functions that appear in the Haskell cheat sheet or elsewhere in the exam.
\begin{verbatim}
 foldTree :: (a -> b -> b) -> b -> Tree a -> b
\end{verbatim}    
\ifshowanswers
\begin{verbatim}
foldTree f d Leaf = d 
foldTree f d (Node v l r) = f v (foldTree f (foldTree f d r) l)
\end{verbatim}    
\else
\bigskip 
\bigskip 
\bigskip 
\bigskip 
\bigskip 
\bigskip 
\bigskip 
\bigskip 
\bigskip 
\bigskip 
\bigskip 
\bigskip 
\fi

\item \textbf{[5pts]} Implement \texttt{maxIntTree}, 
which returns the largest \texttt{Int} in a tree of integers (or 0 for an empty tree).
You may only use library functions that appear in the Haskell cheat sheet or elsewhere in the exam.
\begin{verbatim}
 maxIntTree :: Tree Int -> Int 
\end{verbatim}
\ifshowanswers
\begin{lstlisting}
maxIntTree = foldTree max 0
\end{lstlisting}
\else
\bigskip 
\bigskip 
\bigskip 
\bigskip 
\bigskip 
\bigskip 
\bigskip 
\bigskip 
\bigskip 
\bigskip 
\bigskip 
\fi

\item \textbf{[5pts]} 
  Now implement \texttt{maxTree}, a version of \texttt{maxIntTree} that works for any kind of tree. That is, for a tree of type \texttt{Tree a}, it returns 
   the maximum value or a default value for the empty tree.
  You may only use library functions that appear in the Haskell cheat sheet or elsewhere in the exam. You must also specify the type of your implementation.  
  Note that the tree elements may appear in any order—do not assume the tree is a BST.

\ifshowanswers 
\begin{lstlisting}
 maxTree :: Ord a => a -> Tree a -> a
 maxTree d = foldTree max d
\end{lstlisting}
\else
\begin{verbatim}

 maxTree :: ___________________________________________
\end{verbatim}
\bigskip 
\bigskip 
\bigskip 
\bigskip 
\bigskip 
\bigskip 
\bigskip 
\bigskip 
\bigskip 
\bigskip 
\bigskip 
\bigskip 
\fi

\item \textbf{[10pts]} Implement \texttt{joinTree} which creates a single tree out of two trees
by replacing the left-most leaf node of the second tree.  

For example, the output of \texttt{joinTree (Node "boo" Leaf Leaf) t} should return
\begin{verbatim}
(Node "foo"  
  (Node "bar" (Node "baz"(Node "boo" Leaf Leaf) Leaf) Leaf) 
  (Node "qux" Leaf (Node "quux" Leaf Leaf)))
\end{verbatim}

\begin{verbatim}
joinTree :: Tree a -> Tree a -> Tree a
\end{verbatim}
      
\ifshowanswers 
\begin{lstlisting}
 joinTree t Leaf = t 
 joinTree t (Node v l r) = Node v (joinTree t l) r 
\end{lstlisting}
\else
     \bigskip
     \bigskip
     \bigskip
     \bigskip
     \bigskip
     \bigskip
     \bigskip
     \bigskip
     \bigskip
     \bigskip
\fi

\newpage
\item \textbf{[20pts]} Implement a \texttt{filter} function for the \texttt{Tree} datatype
which takes a predicate and a tree and returns a tree containing only the values for which 
the predicate was true. For example, \verb|filterTree (\x -> length x >= 4) t| should return
\begin{verbatim}
(Node "quux" Leaf Leaf)
\end{verbatim}
and \verb|filterTree (\x -> x /= "foo") t| should return
\begin{verbatim}
(Node "qux" (Node "bar" (Node "baz" Leaf Leaf) Leaf) 
            (Node "quux" Leaf Leaf))
\end{verbatim}
You may only use library functions that appear in the Haskell cheat sheet or elsewhere in the exam.

\begin{verbatim}
 filterTree :: (a -> Bool) -> Tree a -> Tree a
\end{verbatim}

\ifshowanswers 
\begin{lstlisting}
 filterTree p Leaf = Leaf
 filterTree p (Node v l r) | p v = 
   Node v (filterTree p l) (filterTree p r) 
 filterTree p (Node v l r) | otherwise = 
   case filterTree p l of 
     Leaf -> filterTree p r
     fl   -> case filterTree p r of
               Leaf -> fl
               fr   -> joinTree fl fr
\end{lstlisting}
    \else
     \bigskip
     \bigskip
     \bigskip 
     \bigskip
     \bigskip 
     \bigskip
     \bigskip
     \bigskip 
     \bigskip
     \bigskip
    \fi
 

\end{enumerate}
\newpage
\[ \]
\newpage
\section{Lambda calculus cheat sheet}
\begin{lstlisting}
-- Booleans --------------------------------
let TRUE =\x y -> x
let FALSE = \x y -> y
let ITE = \b x y -> b x y
let NOT = \b x y -> b y x
let AND = \b1 b2 -> ITE b1 b2 FALSE 
let OR = \b1 b2 -> ITE b1 TRUE b2

-- Numbers ---------------------------------
let ZERO = \f x-> x
let ONE = \f x -> f x 
let TWO = \f x -> f (f x) 
let THREE = \f x -> f (f (f x))
let FOUR = \f x -> f (f (f (f x))
let FIVE = \f x -> f (f (f (f (f x))

-- Pairs -----------------------------------
let PAIR = \x y b -> b x y 
let FST = \p -> p TRUE 
let SND = \p -> p FALSE

-- Lists -----------------------------------
let EMPTY = \xs -> xs (\x y z -> FALSE) TRUE
let CONS  = PAIR
let NIL   = FALSE
let HEAD  = FST
let TAIL  = SND

-- Arithmetic ------------------------------
let INC   = \n f x -> f (n f x)
let ADD   = \n m -> n INC m 
let MUL   = \n m -> n (ADD m) ZERO
let ISZ   = \n ->   -- return TRUE if n == 0 --
let DECR  = \n ->   -- decrement n by one --  
let EQL   = \a b -> -- return TRUE if a == b, otherwise FALSE --

-- Recursion -------------------------------
let FIX = \stp -> (\x -> stp (x x)) (\x -> stp (x x))
\end{lstlisting}

\newpage
\section{Haskell cheat sheet}
\begin{lstlisting}
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr f b []     = b
foldr f b (x:xs) = f x (foldr f b xs)

foldl :: (b -> a -> b) -> b -> [a] -> b
foldl f b xs          = helper b xs
  where
    helper acc []     = acc
    helper acc (x:xs) = helper (f acc x) xs

filter :: (a -> Bool) -> [a] -> [a]
filter pred []    = []
filter pred (x:xs)
  | pred x         = x : filter pred xs
  | otherwise      = filter pred xs

map :: (a -> b) -> [a] -> [b]
map _ []     = []
map f (x:xs) = f x : map f xs

flip :: (a -> b -> c) -> b -> a -> c
flip f x y = f y x

(++) :: [a] -> [a] -> [a]
(++) []     ys = ys
(++) (x:xs) ys = x : xs ++ ys

even :: (Integral a) => a -> Bool
(==) :: Eq a => a -> a -> Bool
max  :: Ord a => a -> a -> a
(<)  :: Ord a => a -> a -> Bool
(>)  :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
\end{lstlisting}

\end{document}
